module Control.Monad.Free where

open import Prelude
  hiding (fold)

record Free (f : Set -> Set) (a : Set) : Set where
  constructor Free:
  field run : forall {m} {{_ : Monad m}} -> (f ~> m) -> m a

open Free

lift : forall {f} -> f ~> Free f
lift x = Free: λ t -> t x

interpret : forall {f m} {{_ : Monad m}} -> (f ~> m) -> Free f ~> m
interpret t free = run free t

lower : forall {m} {{_ : Monad m}} -> Free m ~> m
lower = interpret id

instance
  functorFree : forall {f} -> Functor (Free f)
  functorFree .map f free = Free: (map f ∘ run free)

  applicativeFree : forall {f} -> Applicative (Free f)
  applicativeFree .pure x = Free: λ _ -> return x
  applicativeFree ._<*>_ f x = Free: λ t -> run f t <*> run x t

  monadFree : forall {f} -> Monad (Free f)
  monadFree ._>>=_ m f = Free: λ t ->
    join (map (interpret t ∘ f) (interpret t m))

-- Free forms a functor on the category Sets ^ Sets whose map operation is:
hoist : forall {f g} -> (f ~> g) -> Free f ~> Free g
hoist t free = interpret (lift ∘ t) free

-- Free also forms a monad on Sets ^ Sets. The return operation of this monad
-- is lift; the extend operation is defined below:
flatMap : forall {f g} -> (f ~> Free g) -> Free f ~> Free g
flatMap = interpret

-- Free is a free construction. It is basically the left-adjoint of the
-- would-be forgetful functor U that forgets the monad structure of a functor.
-- The right adjunct of this adjunction is basically interpret. The left
-- adjunct is given below.
uninterpret : forall {f m} -> (Free f ~> m) -> f ~> m
uninterpret t x = t (lift x)

-- When F is a functor, Free F A is an F-algebra for any type A. The operation
-- of this algebra is:
impure : forall {f a} -> f (Free f a) -> Free f a
impure op = join (lift op)

-- A fold operation based on the Kleisli triple definition of monad.
fold : forall {f a b}
  -> (a -> b)
  -> (forall {a} -> (a -> b) -> f a -> b)
  -> Free f a -> b
fold {f} ret ext free = interpret t free ret ext
  where

    -- M is the free monad generated by F based on Church encoding of the
    -- Kleisli triple definition of monad.
    M : Set -> Set
    M a = forall {b}
      -> (a -> b)
      -> (forall {c} -> (c -> b) -> f c -> b)
      -> b

    instance
      functorM : Functor M
      functorM .map f m = λ ret ext -> m (ret ∘ f) ext

      applicativeM : Applicative M
      applicativeM .pure x = λ ret ext -> ret x
      applicativeM ._<*>_ f x = λ ret ext ->
        f (λ g -> x (ret ∘ g) ext) ext

      monadM : Monad M
      monadM ._>>=_ m f = λ ret ext -> m (λ y -> (f y) ret ext) ext

    -- The lift operation of the free monad M.
    t : f ~> M
    t x = λ ret ext -> ext ret x

-- A fold operation based on the standard definition of monad. This one
-- requires F to be a functor.
fold' : forall {f a b} {{_ : Functor f}}
  -> (a -> b)
  -> (f b -> b)
  -> Free f a -> b
fold' {f} {{inst}} ret jn free = interpret t free ret jn
  where

    -- M is the free monad generated by F based on Church encoding of the
    -- standard definition of monad.
    M : Set -> Set
    M a = forall {b} -> (a -> b) -> (f b -> b) -> b

    instance
      functorM : Functor M
      functorM .map f m = λ ret jn -> m (ret ∘ f) jn

      applicativeM : Applicative M
      applicativeM .pure x = λ ret jn -> ret x
      applicativeM ._<*>_ f x = λ ret jn ->
        f (λ g -> x (ret ∘ g) jn) jn

      monadM : Monad M
      monadM ._>>=_ m f = λ ret jn -> m (λ x -> (f x) ret jn) jn

    -- The lift operation of the free monad M.
    t : f ~> M
    t x = λ ret jn -> jn ((map {{inst}} ret) x)
