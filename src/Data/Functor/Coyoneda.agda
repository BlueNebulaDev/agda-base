{-# OPTIONS --type-in-type #-}

module Data.Functor.Coyoneda where

open import Control.Category
open import Data.Functor
open import Data.Product

-- This is the existensial version Yoneda C F X.
Coyoneda : (C : Category) -> (ob C → Sets) -> ob C → Set
Coyoneda C F Y = exists \ X -> F X * hom C X Y

-- Coyoneda C F is a functor.
Functor:Coyoneda : (C : Category) (F : ob C → Set)
  -> Functor C Sets (Coyoneda C F)
Functor:Coyoneda C F .map f (_ , x , g) = (_ , x , f <<< g)
  where instance _ = C

-- The coYoneda lemma states that F Y ~= Coyoneda C F Y. The isomorphsim
-- is witnessed by lowerCoyoneda and liftCoyoneda.
lowerCoyoneda : {C : Category} {F : ob C → Set} {{_ : Functor C Sets F}} ->
  let instance _ = Trans: C Sets in
  Coyoneda C F ~> F
lowerCoyoneda (_ , x , f) = map f x

liftCoyoneda : {C : Category} {F : ob C → Set} ->
  let instance _ = Trans: C Sets in
  F ~> Coyoneda C F
liftCoyoneda {C} y = (_ , y , id)
  where instance _ = C

-- It turns out that Coyoneda is a free construction, i.e. Coyoneda C F is the
-- free functor generated by F. This is the right adjunct of the corresponding
-- free/forgetful adjunction.
foldCoyoneda : {C : Category} {F G : ob C → Set} {{_ : Functor C Sets G}} ->
  let instance _ = Trans: C Sets in
  (F ~> G) -> Coyoneda C F ~> G
foldCoyoneda alpha (_ , x , f) = map f (alpha x)

-- This is the left adjunct.
ladjunctCoyoneda : {C : Category} {F G : ob C → Set} {{_ : Functor C Sets G}} ->
  let instance _ = Trans: C Sets in
  (Coyoneda C F ~> G) -> (F ~> G) 
ladjunctCoyoneda {C} alpha x = alpha (liftCoyoneda {C} x)
