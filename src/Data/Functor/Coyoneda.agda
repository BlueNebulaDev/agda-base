{-# OPTIONS --type-in-type #-}

module Data.Functor.Coyoneda where

-- This is the existensial version Yoneda C F X.

open import Control.Category

module Base where
  data Coyoneda (C : Category) (F : ob C -> Set) (Y : ob C) : Set where
    Coyoneda: : forall {X} -> F X -> hom C X Y -> Coyoneda C F Y

open Base public
  hiding (module Coyoneda)

-- Coyoneda C F is a functor.

open import Data.Functor

Functor:Coyoneda : (C : Category) (F : ob C -> Set)
  -> Functor C Sets (Coyoneda C F)
Functor:Coyoneda C F .map f (Coyoneda: x g) = Coyoneda: x (f <<< g)
  where instance _ = C

module Coyoneda where

  -- The coYoneda lemma states that F Y ~= Coyoneda C F Y. The isomorphsim
  -- is witnessed by lower and lift.

  lower : forall {C F X} {{_ : Functor C Sets F}}
    -> Coyoneda C F X -> F X
  lower (Coyoneda: x f) = map f x

  lift : forall {C F X} -> F X -> Coyoneda C F X
  lift {C} y = Coyoneda: y id
    where instance _ = C

  -- It turns out that Coyoneda is a free construction, i.e. Coyoneda C F is
  -- the free functor generated by F. This is the right adjunct of the
  -- corresponding free/forgetful adjunction.

  interpret : forall {C F G} {{_ : Functor C Sets G}} ->
    let instance _ = Trans: C Sets in
    (F ~> G) -> Coyoneda C F ~> G
  interpret t (Coyoneda: x f) = map f (t x)

  -- This is the left adjunct.

  uninterpret : forall {C F G} ->
    let instance _ = Trans: C Sets in
    (Coyoneda C F ~> G) -> F ~> G
  uninterpret {C} t x = t (lift {C} x)
